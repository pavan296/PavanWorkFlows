name: Daily README Update (Reusable)

on:
  workflow_call:
    inputs:
      timezone:
        description: "Timezone for date display (e.g., Asia/Dubai, America/New_York)"
        required: false
        type: string
        default: "UTC"
      readme_template:
        description: "Custom README template type (default, minimal, detailed)"
        required: false
        type: string
        default: "default"
      quote_category:
        description: "Quote category (inspirational, motivational, wisdom, success)"
        required: false
        type: string
        default: ""
      enable_stats:
        description: "Enable repository statistics in README"
        required: false
        type: boolean
        default: true
    secrets:
      token:
        description: "GitHub token for committing"
        required: false

jobs:
  update-readme:
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.token || secrets.GITHUB_TOKEN }}
          fetch-depth: 0 # For better git history access

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"
          cache: "pip"

      - name: Cache dependencies
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      - name: Install dependencies
        run: |
          pip install --no-cache-dir requests pytz

      - name: Update README
        env:
          TIMEZONE: ${{ inputs.timezone }}
          TEMPLATE: ${{ inputs.readme_template }}
          QUOTE_CATEGORY: ${{ inputs.quote_category }}
          ENABLE_STATS: ${{ inputs.enable_stats }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          python << 'EOF'
          import requests
          import datetime
          import pytz
          import os
          import json
          from urllib.parse import quote as url_quote

          def fetch_quote_with_fallback(category=""):
              """Fetch quote with multiple API fallbacks and local fallbacks."""
              fallback_quotes = [
                  {"content": "The only way to do great work is to love what you do.", "author": "Steve Jobs"},
                  {"content": "Innovation distinguishes between a leader and a follower.", "author": "Steve Jobs"},
                  {"content": "Stay hungry, stay foolish.", "author": "Steve Jobs"},
                  {"content": "Code is poetry.", "author": "Anonymous"},
                  {"content": "First, solve the problem. Then, write the code.", "author": "John Johnson"}
              ]
              
              # Try primary API with category if specified
              apis = []
              if category:
                  apis.append(f'https://api.quotable.io/random?tags={url_quote(category)}')
              apis.extend([
                  'https://api.quotable.io/random',
                  'https://zenquotes.io/api/random',
                  'https://api.adviceslip.com/advice'
              ])
              
              for api_url in apis:
                  try:
                      response = requests.get(api_url, timeout=8)
                      if response.status_code == 200:
                          data = response.json()
                          
                          # Handle different API response formats
                          if 'content' in data and 'author' in data:  # quotable.io
                              return data['content'], data['author']
                          elif isinstance(data, list) and len(data) > 0:  # zenquotes.io
                              quote_data = data[0]
                              return quote_data.get('q', ''), quote_data.get('a', 'Unknown')
                          elif 'slip' in data and 'advice' in data['slip']:  # adviceslip.com
                              return data['slip']['advice'], 'Advice Slip'
                              
                  except Exception as e:
                      print(f"API {api_url} failed: {e}")
                      continue
              
              # Use fallback quote if all APIs fail
              import random
              fallback = random.choice(fallback_quotes)
              return fallback['content'], fallback['author']

          def get_repository_stats():
              """Get repository statistics if enabled."""
              enable_stats = os.environ.get('ENABLE_STATS', 'true').lower() == 'true'
              if not enable_stats:
                  return ""
              
              repo_name = os.environ.get('GITHUB_REPOSITORY', 'repository')
              
              stats = "\n## üìä Repository Stats\n\n"
              stats += f"- **Repository:** {repo_name}\n"
              stats += "- **Workflow:** Daily README Update\n"
              stats += "- **Last Execution:** Just now ‚ö°"
              return stats

          # Get inputs from environment
          timezone_str = os.environ.get('TIMEZONE', 'UTC')
          template_type = os.environ.get('TEMPLATE', 'default')
          quote_category = os.environ.get('QUOTE_CATEGORY', '')

          # Fetch quote
          print("Fetching inspirational quote...")
          quote, author = fetch_quote_with_fallback(quote_category)
          print(f"Quote retrieved: {quote[:50]}..." if len(quote) > 50 else quote)

          # Get current date with timezone
          try:
              tz = pytz.timezone(timezone_str)
              now = datetime.datetime.now(tz)
              today = now.strftime('%B %d, %Y')
              time_str = now.strftime('%I:%M %p %Z')
              week_day = now.strftime('%A')
          except Exception as e:
              print(f"Timezone error: {e}, using UTC")
              now = datetime.datetime.now(pytz.UTC)
              today = now.strftime('%B %d, %Y')
              time_str = now.strftime('%I:%M %p UTC')
              week_day = now.strftime('%A')

          # Generate stats section
          stats_section = get_repository_stats()

          # Generate README based on template type
          if template_type == 'minimal':
              readme_content = "# üìÖ Daily Updates\n\n"
              readme_content += f"**Last Updated:** {today} at {time_str}\n\n"
              readme_content += f"> *\"{quote}\"*  \n"
              readme_content += f"> **‚Äî {author}**{stats_section}\n"
              
          elif template_type == 'detailed':
              readme_content = "# üìä Daily Updates Repository\n\n"
              readme_content += "## üìÖ Last Updated\n"
              readme_content += f"- **Date:** {today}  \n"
              readme_content += f"- **Time:** {time_str}  \n"
              readme_content += f"- **Day:** {week_day}\n\n"
              readme_content += "## üí≠ Quote of the Day\n\n"
              readme_content += f"> *\"{quote}\"*\n> \n"
              readme_content += f"> **‚Äî {author}**\n\n"
              readme_content += "---\n"
              readme_content += stats_section + "\n\n"
              readme_content += "## üìà Calendar Info\n\n"
              readme_content += f"- **Days This Year:** {now.timetuple().tm_yday} of 365\n"
              readme_content += f"- **Current Month:** {now.strftime('%B')}\n"
              readme_content += f"- **Week of Year:** Week {now.isocalendar()[1]}\n"
              season = ['Winter', 'Winter', 'Spring', 'Spring', 'Spring', 'Summer', 'Summer', 'Summer', 'Fall', 'Fall', 'Fall', 'Winter'][now.month-1]
              readme_content += f"- **Season:** {season}\n\n"
              readme_content += "---\n\n"
              readme_content += "## ‚ÑπÔ∏è About\n\n"
              readme_content += "This repository automatically updates daily with inspirational content using GitHub Actions.\n\n"
              readme_content += "**Status:** ‚úÖ Active | **Frequency:** Daily | **Automation:** GitHub Actions\n"
              
          else:  # default
              readme_content = "# üìÖ Daily Updates Repository\n\n"
              readme_content += f"## Last Updated: {today}\n\n"
              readme_content += "## üí≠ Quote of the Day\n\n"
              readme_content += f"> *\"{quote}\"*\n> \n"
              readme_content += f"> **‚Äî {author}**\n\n"
              readme_content += "---\n"
              readme_content += stats_section + "\n\n"
              readme_content += "### ü§ñ About This Repository\n\n"
              readme_content += "This repository is automatically updated daily with inspirational quotes and fresh timestamps.\n\n"
              readme_content += f"**Status:** ‚úÖ Active | **Last Run:** {today} at {time_str}\n\n"
              readme_content += "---\n"
              readme_content += "*Powered by GitHub Actions* üöÄ\n"

          # Write to README.md with error handling
          try:
              with open('README.md', 'w', encoding='utf-8') as f:
                  f.write(readme_content)
              print("‚úÖ README updated successfully!")
              print(f"üìÖ Date: {today}")
              print(f"üí≠ Quote: {quote[:100]}{'...' if len(quote) > 100 else ''}")
              print(f"üë§ Author: {author}")
          except Exception as e:
              print(f"‚ùå Error writing README: {e}")
              exit(1)
          EOF

      - name: Commit and push changes
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add README.md

          # Check if there are changes to commit
          if git diff --cached --quiet; then
            echo "üìã No changes detected in README.md"
            exit 0
          fi

          # Create commit with enhanced message
          COMMIT_DATE=$(date +'%Y-%m-%d %H:%M:%S')
          git commit -m "üìÖ Daily README update: $COMMIT_DATE

          ü§ñ Automated daily content refresh
          üìù Updated quotes and timestamps
          ‚è∞ Timezone: ${{ inputs.timezone }}
          üìã Template: ${{ inputs.readme_template }}"

          # Push changes with retry logic
          for i in {1..3}; do
            if git push; then
              echo "‚úÖ Changes pushed successfully on attempt $i"
              break
            else
              echo "‚ö†Ô∏è  Push attempt $i failed, retrying in 5 seconds..."
              sleep 5
            fi
            
            if [ $i -eq 3 ]; then
              echo "‚ùå Failed to push after 3 attempts"
              exit 1
            fi
          done
